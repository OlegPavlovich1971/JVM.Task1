
public class JvmComprehension {
    // При обнаружении нового, не хранящегося в кеше ClassLoader-ов, класса JvmComprehension, он
    // будет подгружен ClassLoader-ом соответсвующего уровня в Metaspace. JVM выполнит его связывание и
    // инициализацию.
    public static void main(String[] args) {
        int i = 1;                      // 1 в Stack Memory создан фрейм метода main, куда сохранен примитив i.
        Object o = new Object();        // 2 в Metaspace подгружен класс Object. В Heap выделено место для
    // экземпляра соответсвующего класса. В фрейме метода main сохранена ссылка о на него.
        Integer ii = 2;                 // 3 в Metaspace подгружен класс Integer. В Heap сохранен экземпляр
    // соответсвующего класса со значением 2. В фрейме метода main сохранена ссылка ii на него.
        printAll(o, i, ii);             // 4 в Stack Memory создан фрейм метода printAll, куда сохранены ссылки
    // на объекты o, i и ii.
        System.out.println("finished"); // 7 В Heap сохранен экземпляр класса String со значением finished.
    // В Stack Memory создан фрейм метода println, куда в качестве параметра метода сохранена ссылка x на
    // указанный экземпляр класса String. После завершения метода println соответсвующий фрейм из стека
    // будет удален. Также, в связи с завершением, будет удален фрейм метода main. В Heap, до удаления
    // мусорщиком, останутся сохраненные в ходе выполнения программы ссылоные объекты.
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 В Heap сохранен экземпляра класса Integer со
    // значением 700. В фрейме метода printAll сохранена ссылка uselessVar на него.
        System.out.println(o.toString() + i + ii);  // 6 в Metaspace подгружены классы System и String.
    // В ходе инициализации класса System создано поле out. В Stack Memory созданы последовательно фреймы
    // методов println и toString, в последний в качестве параметра метода сохранена ссылка на объект о.
    // В ходе выполнения метода toString для объекта о в Heap сохранен экземпляр класса String со строковым
    // представлением объекта о. То же, с созданием и удалением после выполнения фреймов метода toString,
    // созданием в Heap соответсвующих ссылочных объектов строкового представления, будет выполнено и для
    // объектов i и ii. Результат конкатенации строкового представления объектов o, i и ii будет сохранен в
    // Heap, ссылка на него в качестве параметра х будет сохранена в фрейме метода println. После выполнения
    // метода println соответсвующий фрейм будет удален.
    }
}
